include "../array/int_array.spl";
include "../array/byte_array.spl";
include "../array/copy.spl";
include "../bitvector/intToByteArray.spl";
include "../io/fileIO.spl";
include "../array/copyByte.spl";

procedure constructPacket(mode: Int, version: Int)
  returns (packet: Array<Byte>)
  //requires emp
  requires mode <= 0xFF && mode >= 0
  requires version <= 0xFF && version >= 0
  ensures byte_array(packet)
  ensures packet.length == 12
  //ensures forall i: Int:: i >= 1 && i < packet.length ==> packet[i] == 0
{
  packet := new Array<Byte>(12);

  var i := 0;

  while (i < packet.length)
    invariant i >= 0 && i <= packet.length
    invariant byte_array(packet)
    invariant forall k: Int :: 0 <= k && k < i ==> packet[k] == int2byte(0)
  {
    packet[i] := int2byte(0);
    i := i + 1;
  }

  packet[0] := (packet[0] & int2byte(0xC7)) | int2byte(mode);
  packet[0] := (packet[0] & int2byte(0xC7)) | int2byte(version) <-< 3;

  return packet;
}

procedure client(host: Array<Byte>, mode: Int, version: Int)
  returns (time: Int)
  requires mode <= 0xFF && mode >= 0
  requires version <= 0xFF && version >= 0
  requires byte_array(host)
  requires host.length == 4
  //DZ: the next line is not needed since we have a Byte type now
  //requires forall i: Int:: i >= 0 && i < host.length ==> host[i] <= int2byte(0xFF) && host[i] > int2byte(0)
  ensures byte_array(host)
{
  var flags := 0;
  
  var fd := gopen(host, flags);

  //there was an error when opening the file
  if (fd == -1) {
    return 1;
  }

  var packet := constructPacket(mode, version);

  var buffer := copyByte(packet);


  var temp := gwrite(fd, buffer);

  temp := greadOffset(fd, buffer, 0);

  //var ret1 := buffer[9] * int2byte(1000000000);
  //var ret2 := buffer[10] * (int2byte(1000000000) >-> 32);
  //var retF := ret1 + ret2;
 // return byte2int(retF);

  var res := byte2int(buffer[9] * int2byte(1000000000) + (buffer[10] * (int2byte(1000000000) >-> 32)));
  free(packet);
  free(buffer);
  temp := gclose(fd);
  return res;
  //return flags;
}

procedure Main(args: Array<Byte>)
  returns (res: Int)
  requires byte_array(args)
  ensures  byte_array(args)
{
  if (args.length != 4) {
    return 1;
  }
  res := client(args, 1, 1);
  return res;
}
