include "../array/byte_array.spl";
include "../array/copy.spl";
include "../bitvector/intToByteArray.spl";
include "../io/fileIO.spl";

procedure checkPacket(packet: Array<Byte>)
  returns (valid: Int)
  requires byte_array(packet)
  requires packet.length == 12
  ensures byte_array(packet)
{
  var l := (packet[0] & int2byte(0xFF)) >-> 6;
  var vt := ((packet[0] & int2byte(0xFF)) <-< 2);
  var v := vt  >-> 5; 
  var mt := ((packet[0] & int2byte(0xFF)) <-< 5);
  var m := mt >-> 5;  

  valid := 0;

  if( l == int2byte(0) || l == int2byte(3)){
    if( v >= int2byte(1) && v <= int2byte(4)){
      if( m == int2byte(3)){
        valid := 1;
      }
    }
  }

  return valid;
}

procedure constructPacket(req: Array<Byte>)
  returns (packet: Array<Byte>)
  requires byte_array(req)
  requires req.length == 12
  ensures byte_array(packet) &*& byte_array(req)
  ensures packet.length == 12
{
  packet := new Array<Byte>(12);

  var seconds := int2byte(1);
  var fraction := int2byte(1);

  packet[0] := (req[0] & int2byte(0x38)) + int2byte(1);
  packet[0] := packet[0] + (int2byte(1) <-< 8);
  packet[0] := packet[0] + (req[0] & (int2byte(0xFF) <-< 16));
  packet[0] := packet[0] + (int2byte(0xEC) <-< 24);

  packet[1] := int2byte(0);
  packet[2] := int2byte(0);

  packet[3] := int2byte(0x5443494E);

  packet[4] := seconds;
  packet[5] := int2byte(0);

  packet[6] := req[10];
  packet[7] := req[11];

  packet[8] := seconds;
  packet[9] := fraction;

  packet[10] := req[10];
  packet[11] := req[11];
}

procedure server(host: Array<Byte>)
  //returns emp
  requires byte_array(host)
  // requires host.length == 4
  // requires forall i: Int:: i >= 0 && i < host.length ==> host[i] < 256 && host[i] > 0
  ensures byte_array(host)
{
  var flags := 0;
  var fd := gopen(host, flags);

  //check the FD is valid
  if (fd == -1) {
      return;
  }

  var buffer := new Array<Byte>(12);
  var temp := gread(fd, buffer);

  if( checkPacket(buffer) != 0 ){
    var packet := constructPacket(buffer);
    temp := gwrite(fd, packet);
    free(packet);
  }
  free(buffer);
  temp := gclose(fd);
}

procedure Main(args: Array<Byte>)
  returns (res: Int)
  requires byte_array(args)
  ensures byte_array(args)
{
  server(args);
  res := 0; //got to return something?
  return res;
}
