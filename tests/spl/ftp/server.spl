include "../../../lib/socket.spl";
include "../../../lib/file.spl";
include "../../../lib/console.spl";
include "../array/string.spl";

procedure connectMeCommand(port: Array<Byte>) returns (res: Int)
  requires byte_array(port)
  ensures byte_array(port)
{
  var cmdAddr := get_address4(null, port);
  free(port);
  if (cmdAddr == null) {
    return -1;
  }

  var cmdFd := create_socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (cmdFd == -1) {
    free(cmdAddr);
    return -1;
  }
    
  var bound := bind4(cmdFd, cmdAddr);
  if (!bound) {
    free(cmdAddr);
    return -1;
  }

  var listening := glisten(cmdFd, 10);
  if (!listening) {
    free(cmdAddr);
    return -1;
  }
  
  var connFd := accept4(cmdFd, cmdAddr);
  free(cmdAddr);
  var closed := gclose(cmdFd);
  return connFd;
}

procedure recvDataConnection(cmdFd: Int) returns (res: Int)
  requires cmdFd > -1
{
  var resp := new Array<Byte>(10);
  var response := tcp_recv(cmdFd, resp);
  //  var port := atoi(resp);
  free(resp);
  
  var fd := create_socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    return -1;
  }
  var portArray := new Array<Byte>(5);
  portArray[0] := response[5];
  portArray[1] := response[6];
  portArray[2] := response[7];
  portArray[3] := response[8];
  portArray[4] := response[9];
  var addr := get_address4(null, portArray);
  if (addr == null){
    return -1;
  }
  
  if (connect4(fd, addr)) {
    free(addr);
    return fd;
  } else {
    free(addr);
    var closing := gclose(fd);
    return -1;
  }
}

procedure handleAuth(cmdFd: Int)
  returns (success: Bool)
  requires cmdFd >= 0
{
  var userName := new Array<Byte>(12); //we're capping the username message out at 12
  var recvUser := tcp_recv(cmdFd, userName);
  free(userName);
  var response := new Array<Byte>(4);
  response := "331"; //we don't actually do anything with the username
  var sent := tcp_send(cmdFd, response, 4);
  free(response);

  var sentPassword := new Array<Byte>(15);
  var recvpass := tcp_recv(cmdFd, sentPassword);

  var pass := new Array<Byte>(15);
  pass := "PASS anonymous";
  var isOkay := false;
  if (pass == sentPassword) {
    isOkay := true;
  }
  free(sentPassword);
  free(pass);

  var response := new Array<Byte>(4);
  if (isOkay) {
    response := "230";
    var sent := tcp_send(cmdFd, response, 4);
    free(response);
    return true;
  } else {
    response := "430";
    var sent := tcp_send(cmdFd, response, 4);
    free(response);
    return false;
  }
}

procedure accept_incoming_file(dataFd: Int, filename: Array<Byte>) returns (res:Int)
  requires (dataFd > 0)
  requires (byte_array(filename))
  ensures (byte_array(filename))
  ensures (dataFd > 0)
  ensures res >= -1
{
  var buffer := new Array<Byte>(65535);//max size, since we don't know incoming file size
  var recv := tcp_recv(dataFd, buffer);
  if (recv < 0) {
    free(buffer);
    return -1;
  }
  var fileFd := gopen(filename, O_CREAT | O_TRUNC);
  if (fileFd < 0) {
    return -1;
  }
  var written := gwrite(fileFd, buffer);
  if (written < 0) {
    free(buffer);
    return -1;
  }
  var closed := gclose(fileFd);
  if (closed < 0) {
    return -1;
  }
  return 1;
}
procedure send_outgoing_file(dataFd: Int, filename: Array<Byte>) returns (res:Int)
  requires (dataFd > 0)
  requires byte_array(filename)
  ensures (dataFd > 0)
  ensures (res >= -1)
  ensures byte_array(filename)
{
  var fileFd := gopen(filename, O_CREAT);
  var flag := false;
  if (fileFd < 0){
    flag := true;
  }
  var fileS := fileSize(filename);
  if (fileS < 0) {
    fileS := 0; //we need it to be zero in order to allocate the array
    flag := true;
  }
  var buffer := new Array<Byte>(fileS);
  
  var read := gread(fileFd, buffer);
  if (read < 0){
    flag := true;
  }
  var closed := gclose(fileFd);
  if (closed < 0) {
    flag := true;
  }
  var sent := tcp_send(dataFd, buffer, fileS);
  if (sent < 0) {
    flag := true;
  }
  return !flag; 
}

procedure server(args: Array<Byte>) returns (res:Int)
{
  var port := new Array<Byte>(5);
  port := "4444";

  var cmdFd := connectMeCommand(port);
  var dataConnFd := recvDataConnection(cmdFd);
  
  var authenticated := handleAuth(cmdFd);

  if (!authenticated){
    return -1;
  }
  //if handleAuth fails, abort.

  var iQuit := false;
  while (!iQuit)
    invariant bool(iQuit)
  {
    var request := new Array<Byte>(100); // it needs to be so big to hold the filename
    var recd := tcp_recv(cmdFd, request);
    var typeCom := new Array<Byte>(5);
    typeCom[0] := request[0];
    typeCom[1] := request[1];
    typeCom[2] := request[2];
    typeCom[3] := request[3];
    typeCom[4] := int2byte(0);
    var filename := copy_byte_slice(request, 5, (request.length -1));
    free(request);
    if (typeCom == "STOR") {
      var ok := new Array<Byte>(4);
      ok := "150";
      var sent := tcp_send(cmdFd, ok, 4);
      free(ok);
      var stored := accept_incoming_file(dataFd, filename);
      if (stored < 0) {
      	var notOk := new Array<Byte>(4);
        notOk := "550";
        sent := tcp_send(cmdFd, notOk, 4);
	free(notOk);
        free(filename);
        free(typeCom);
        iQuit := true;
      }
      var goodPacket := new Array<Byte>(4);
      goodPacket := "250";
      var sent := tcp_send(cmdFd, goodPacket, 4);
      free(filename);
      free(typeCom);
      iQuit := true;
    }
    if (typeCom == "SIZE") {
      var sizeF := fileSize(filename);
      if (sizeF < 0) {
	//file doesn't exist, or we can't get at it
	var badPacket := new Array<Byte>(4);
        badPacket := "550";
	var sent := tcp_send(cmdFd, badPacket, 4);
	free(badPacket);
        free(filename);
        free(typeCom);
        iQuit := true;
      }
      var sizeByte := byte2int(sizeF);
      var sizePacket := new Array<Byte>(1);
      sizePacket := sizeByte;
      var goodPacket := new Array<Byte>(7);
      goodPacket := "213 "; //potential bug: do we need to strip the end character?  Made it size 7 just in case strcat did not strip it.  But we really only need size 6
      var finished := strcat(sizePacket, goodPacket);
      var sent := tcp_sent(cmdFd, goodPacket, 7); //should be six
      free(sizePacket);
      free(goodPacket);
    }
    if (typeCom == "RETR") {
      var ok := new Array<Byte>(4);
      ok := "150";
      var sent := tcp_send(cmdFd, ok, 4);
      free(ok);
      sent := send_outgoing_file(dataFd, filename);
      if (!sent){
	      //we failed
	var notOk := new Array<Byte>(4);
        notOk := "550";
        sent := tcp_send(cmdFd, notOk, 4);
	free(notOk);
        free(filename);
        free(typeCom);
        iQuit := true;
      }
      var goodPacket := new Array<Byte>(4);
      goodPacket := "250";
      var sent := tcp_send(cmdFd, goodPacket, 4);
      free(filename);
      free(typeCom);
      iQuit := true;
    }
    else {
      free(filename);
      free(typeCom);
      var badPacket := new Array<Byte>(4);
      badPacket := "500";
      var sent := tcp_send(cmdFd, badPacket, 4);
      free(badPacket);
      iQuit := true;
      //something we did not expect
    }
  }
  var quitBuff := new Array<Byte>(5);
  var recv := tcp_recv(cmdFd, quitBuff);
  if (quitBuff == "QUIT") {
    var closed := gclose(cmdFd);
    closed := gclose(dataFd);
    return 0;
  }
  else {
    return -1;
  }

}
