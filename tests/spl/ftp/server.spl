include "../../../lib/socket.spl";
include "../../../lib/file.spl";
include "../../../lib/console.spl";
include "../array/string.spl";
include "../array/copy_byte_slice.spl";

procedure connectMeCommand(port: Array<Byte>) returns (res: Int)
  requires byte_array(port)
  ensures byte_array(port)
{
  var cmdAddr := get_address4(null, port);
  free(port);
  if (cmdAddr == null) {
    return -1;
  }

  var cmdFd := create_socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (cmdFd == -1) {
    free(cmdAddr);
    return -1;
  }
    
  var bound := bind4(cmdFd, cmdAddr);
  if (!bound) {
    free(cmdAddr);
    return -1;
  }

  var listening := glisten(cmdFd, 10);
  if (!listening) {
    free(cmdAddr);
    return -1;
  }
  
  var connFd := accept4(cmdFd, cmdAddr);
  free(cmdAddr);
  var closed := gclose(cmdFd);
  return connFd;
}

procedure recvDataConnection(cmdFd: Int) returns (res: Int)
  requires cmdFd > -1
{
  var resp := new Array<Byte>(10);
  var response := tcp_recv(cmdFd, resp);
  //  var port := atoi(resp);
  free(resp);
  
  var fd := create_socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    return -1;
  }
  var portArray := copy_byte_slice(resp, 5, 10);
  //  portArray[0] := response[5];
  //portArray[1] := response[6];
  //portArray[2] := response[7];
  //portArray[3] := response[8];
  //portArray[4] := response[9];
  var addr := get_address4(null, portArray);
  if (addr == null){
    return -1;
  }
  
  if (connect4(fd, addr)) {
    free(addr);
    return fd;
  } else {
    free(addr);
    var closing := gclose(fd);
    return -1;
  }
}

procedure handleAuth(cmdFd: Int)
  returns (success: Bool)
  requires cmdFd >= 0
{
  var userName := new Array<Byte>(12); //we're capping the username message out at 12
  var recvUser := tcp_recv(cmdFd, userName);
  free(userName);
  var response := new Array<Byte>(4);
  response := "331"; //we don't actually do anything with the username
  var sent := tcp_send(cmdFd, response, 4);
  free(response);

  var sentPassword := new Array<Byte>(15);
  var recvpass := tcp_recv(cmdFd, sentPassword);

  var pass := new Array<Byte>(15);
  pass := "PASS anonymous";
  var isOkay := false;
  if (pass == sentPassword) {
    isOkay := true;
  }
  free(sentPassword);
  free(pass);

  response := new Array<Byte>(4);
  if (isOkay) {
    response := "230";
    var sent := tcp_send(cmdFd, response, 4);
    free(response);
    return true;
  } else {
    response := "430";
    var sent := tcp_send(cmdFd, response, 4);
    free(response);
    return false;
  }
}

procedure accept_incoming_file(dataFd: Int, filename: Array<Byte>) returns (res:Int)
  requires (dataFd > 0)
  requires (byte_array(filename))
  ensures (byte_array(filename))
  ensures (dataFd > 0)
  ensures res >= -1
{
  var buffer := new Array<Byte>(65535);//max size, since we don't know incoming file size
  var recv := tcp_recv(dataFd, buffer);
  if (recv < 0) {
    free(buffer);
    return -1;
  }
  var fileFd := gopen(filename, O_CREAT | O_TRUNC);
  if (fileFd < 0) {
    return -1;
  }
  var written := gwrite(fileFd, buffer);
  if (written < 0) {
    free(buffer);
    return -1;
  }
  var closed := gclose(fileFd);
  if (closed < 0) {
    return -1;
  }
  return 1;
}
procedure send_outgoing_file(dataFd: Int, filename: Array<Byte>) returns (res: Bool)
  requires (dataFd > 0)
  requires byte_array(filename)
  ensures (dataFd > 0)
  ensures byte_array(filename)
{
  var fileFd := gopen(filename, O_CREAT);
  var flag := false;
  if (fileFd < 0){
    flag := true;
  }
  var fileS := fileSize(filename);
  if (fileS < 0) {
    fileS := 0; //we need it to be zero in order to allocate the array
    flag := true;
  }
  var buffer := new Array<Byte>(fileS);
  
  var read := gread(fileFd, buffer);
  if (read < 0){
    flag := true;
  }
  var closed := gclose(fileFd);
  if (closed < 0) {
    flag := true;
  }
  var sent := tcp_send(dataFd, buffer, fileS);
  if (sent < 0) {
    flag := true;
  }
  //we want to return !flag
  if (flag) {
    return false;
  } else {
    return true;
  }
}

procedure store_help(cmdFd: Int, dataFd: Int, filename: Array<Byte>) returns (fail: Bool)
  requires cmdFd > 0;
  requires dataFd > 0;
  requires byte_array(filename);
  ensures cmdFd > 0;
  ensures dataFd > 0;
  ensures byte_array(filename);
{
  var ok := new Array<Byte>(4);
  ok := "150";
  var sent := tcp_send(cmdFd, ok, 4);
  free(ok);
  var stored := accept_incoming_file(dataFd, filename);
  if (stored < 0) {
    var notOk := new Array<Byte>(4);
    notOk := "550";
    sent := tcp_send(cmdFd, notOk, 4);
    free(notOk);
    fail := true;
    return fail;
  }
  var goodPacket := new Array<Byte>(4);
  goodPacket := "250";
  sent := tcp_send(cmdFd, goodPacket, 4);
  fail := true;
  return fail;
}

procedure size_help(cmdFd: Int, filename: Array<Byte>) returns (fail: Bool)
  requires cmdFd > 0;
  requires byte_array(filename);
  ensures cmdFd > 0;
  ensures byte_array(filename);
{
  var sizeF := fileSize(filename); //an int
  if (sizeF < 0) {
    //file doesn't exist, or we can't get at it
    var badPacket := new Array<Byte>(4);
    badPacket := "550";
    var sent := tcp_send(cmdFd, badPacket, 4);
    free(badPacket);
    return true;
  }
  var sizePacket := new Array<Byte>(1);
  sizePacket[0] := int2byte(sizeF);
  var goodPacket := new Array<Byte>(6);
  goodPacket := "213 "; 
  var finished := strcat(sizePacket, goodPacket);
  var sent := tcp_send(cmdFd, goodPacket, 6);
  free(sizePacket);
  free(goodPacket);
  return false;
}

procedure retr_help(cmdFd: Int, dataFd: Int, filename: Array<Byte>) returns (fail: Bool)
  requires cmdFd > 0;
  requires dataFd > 0;
  requires byte_array(filename);
  ensures cmdFd > 0;
  ensures dataFd > 0;
  ensures byte_array(filename);
{
  var ok := new Array<Byte>(4);
  ok := "150";
  var sent := tcp_send(cmdFd, ok, 4);
  free(ok);
  var done := send_outgoing_file(dataFd, filename);
  if (!done){
    //we failed
    var notOk := new Array<Byte>(4);
    notOk := "550";
    sent := tcp_send(cmdFd, notOk, 4);
    free(notOk);
    return true;
  }
  var goodPacket := new Array<Byte>(4);
  goodPacket := "250";
  sent := tcp_send(cmdFd, goodPacket, 4);
  return true;
}

procedure process_string(thing:Array<Byte>) returns (out: Array<Byte>)
  requires byte_array(thing)
  ensures byte_array(thing)
{
  if (thing[thing.length-1] != int2byte(0)){
    var out := new Array<Byte>(thing.length + 1);
    out := thing;
    out[out.length -1] := int2byte(0);
    return out;
  }
  return out;
}

procedure server() returns (res:Int)
  ensures res >= -1;
{
  var port := new Array<Byte>(5);
  port := "4444";

  var cmdFd := connectMeCommand(port);
  var dataFd := recvDataConnection(cmdFd);
  
  var authenticated := handleAuth(cmdFd);

  if (!authenticated){
    return -1;
  }
  //if handleAuth fails, abort.

  var iQuit := false;
  while (!iQuit)
    //   invariant boolean(iQuit)
  {
    var request := new Array<Byte>(100); // it needs to be so big to hold the filename
    var recd := tcp_recv(cmdFd, request);
    //   var typeCom := new Array<Byte>(5);
    var typeCom := copy_byte_slice(request, 0, 4);
    //  typeCom[0] := request[0];
    //typeCom[1] := request[1];
    //typeCom[2] := request[2];
    //typeCom[3] := request[3];
    //typeCom[4] := int2byte(0);
    var filename := copy_byte_slice(request, 5, (request.length -1));
    free(request);
    var final := process_string(typeCom);
    free(typeCom);
    var stor := new Array<Byte>(5);
    stor := "STOR";
    var sizeCheck := new Array<Byte>(5);
    sizeCheck := "SIZE";
    var retr := new Array<Byte>(5);
    retr := "RETR";
    if (final == stor) {
      var temp := store_help(cmdFd, dataFd, filename);
      if (temp) {
	free(filename);
	free(final);
	free(retr);
	free(stor);
	free(sizeCheck);
      }
      iQuit := temp;
    }
    if (final == sizeCheck) {
      var temp := size_help(cmdFd, filename);
      if (temp) {
	free(filename);
	free(final);
	free(retr);
	free(stor);
	free(sizeCheck);
      }
      iQuit := temp;
    }
    if (typeCom == retr) {
      var temp := retr_help(cmdFd, dataFd, filename);
      if (temp) {
	free(filename);
	free(final);
	free(retr);
	free(stor);
	free(sizeCheck);
      }
      iQuit := temp;
    }
    else {
      free(filename);
      free(final);
      free(retr);
      free(stor);
      free(sizeCheck);
      var badPacket := new Array<Byte>(4);
      badPacket := "500";
      var sent := tcp_send(cmdFd, badPacket, 4);
      free(badPacket);
      iQuit := true;
      //something we did not expect
    }
  }
 
  var quitBuff := new Array<Byte>(5);
  var recv := tcp_recv(cmdFd, quitBuff);
  var quit := new Array<Byte>(5);
  quit := "QUIT";
  if (quitBuff == quit) {
    free(quit);
    var closed := gclose(cmdFd);
    closed := gclose(dataFd);
    return 0;
  }
  else {
    free(quit);
    return -1;
  }
}

procedure Main(args: Array<Byte>)
  returns (res:Int)
  requires byte_array(args)
  ensures byte_array(args)
{
  res := server();
  return res;
}
